{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, Component, NgModule } from '@angular/core';\nimport { Observable } from 'rxjs';\n\nclass NgxCSVParserError {}\n\nclass NgxCsvParser {\n  constructor() {\n    this.defaultCSVParserConfig = {\n      header: true,\n      delimiter: ',',\n      encoding: 'utf8'\n    };\n  }\n\n  parse(csvFile, config) {\n    config = { ...this.defaultCSVParserConfig,\n      ...config\n    };\n    const ngxCSVParserObserver = new Observable(observer => {\n      try {\n        let csvRecords = null;\n\n        if (this.isCSVFile(csvFile)) {\n          const reader = new FileReader();\n          reader.readAsText(csvFile, config.encoding);\n\n          reader.onload = () => {\n            const csvData = reader.result.trim();\n\n            if (csvData) {\n              const csvRecordsArray = this.csvStringToArray(csvData, config.delimiter);\n              const headersRow = this.getHeaderArray(csvRecordsArray);\n              csvRecords = this.getDataRecordsArrayFromCSVFile(csvRecordsArray, headersRow.length, config);\n              observer.next(csvRecords);\n            } else {\n              observer.next([]);\n            }\n\n            observer.complete();\n          };\n\n          reader.onerror = () => {\n            this.badCSVDataFormatErrorHandler(observer);\n          };\n        } else {\n          this.notCSVFileErrorHandler(observer);\n        }\n      } catch (error) {\n        this.unknownCSVParserErrorHandler(observer);\n      }\n    });\n    return ngxCSVParserObserver;\n  }\n\n  csvStringToArray(csvDataString, delimiter) {\n    const regexPattern = new RegExp(`(\\\\${delimiter}|\\\\r?\\\\n|\\\\r|^)(?:\\\"((?:\\\\\\\\.|\\\"\\\"|[^\\\\\\\\\\\"])*)\\\"|([^\\\\${delimiter}\\\"\\\\r\\\\n]*))`, 'gi');\n    let matchedPatternArray = regexPattern.exec(csvDataString);\n    const resultCSV = [[]];\n\n    while (matchedPatternArray) {\n      if (matchedPatternArray[1].length && matchedPatternArray[1] !== delimiter) {\n        resultCSV.push([]);\n      }\n\n      const cleanValue = matchedPatternArray[2] ? matchedPatternArray[2].replace(new RegExp('[\\\\\\\\\"](.)', 'g'), '$1') : matchedPatternArray[3];\n      resultCSV[resultCSV.length - 1].push(cleanValue);\n      matchedPatternArray = regexPattern.exec(csvDataString);\n    }\n\n    return resultCSV;\n  }\n\n  getDataRecordsArrayFromCSVFile(csvRecordsArray, headerLength, config) {\n    const dataArr = [];\n    const headersArray = csvRecordsArray[0];\n    const startingRowToParseData = config.header ? 1 : 0;\n\n    for (let i = startingRowToParseData; i < csvRecordsArray.length; i++) {\n      const data = csvRecordsArray[i];\n\n      if (data.length === headerLength && config.header) {\n        const csvRecord = {};\n\n        for (let j = 0; j < data.length; j++) {\n          if (data[j] === undefined || data[j] === null) {\n            csvRecord[headersArray[j]] = '';\n          } else {\n            csvRecord[headersArray[j]] = data[j].trim();\n          }\n        }\n\n        dataArr.push(csvRecord);\n      } else {\n        dataArr.push(data);\n      }\n    }\n\n    return dataArr;\n  }\n\n  isCSVFile(file) {\n    return file.name.toLowerCase().endsWith('.csv');\n  }\n\n  getHeaderArray(csvRecordsArr) {\n    const headers = csvRecordsArr[0];\n    const headerArray = [];\n\n    for (const header of headers) {\n      headerArray.push(header);\n    }\n\n    return headerArray;\n  }\n\n  notCSVFileErrorHandler(observer) {\n    const ngcCSVParserError = this.errorBuilder('NOT_A_CSV_FILE', 'Selected file is not a csv File Type.', 2);\n    observer.error(ngcCSVParserError);\n  }\n\n  unknownCSVParserErrorHandler(observer) {\n    const ngcCSVParserError = this.errorBuilder('UNKNOWN_ERROR', 'Unknown error. Please refer to official documentation for library usage.', 404);\n    observer.error(ngcCSVParserError);\n  }\n\n  badCSVDataFormatErrorHandler(observer) {\n    const ngcCSVParserError = this.errorBuilder('BAD_CSV_DATA_FORMAT', 'Unable to parse CSV File.', 1);\n    observer.error(ngcCSVParserError);\n  }\n\n  errorBuilder(type, message, code) {\n    const ngcCSVParserError = new NgxCSVParserError();\n    ngcCSVParserError.type = type;\n    ngcCSVParserError.message = message;\n    ngcCSVParserError.code = code;\n    return ngcCSVParserError;\n  }\n\n}\n\nNgxCsvParser.ɵfac = function NgxCsvParser_Factory(t) {\n  return new (t || NgxCsvParser)();\n};\n\nNgxCsvParser.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxCsvParser,\n  factory: NgxCsvParser.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxCsvParser, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\nclass NgxCsvParserComponent {\n  constructor() {}\n\n  ngOnInit() {}\n\n}\n\nNgxCsvParserComponent.ɵfac = function NgxCsvParserComponent_Factory(t) {\n  return new (t || NgxCsvParserComponent)();\n};\n\nNgxCsvParserComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: NgxCsvParserComponent,\n  selectors: [[\"lib-ngx-csv-parser\"]],\n  decls: 2,\n  vars: 0,\n  template: function NgxCsvParserComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"p\");\n      i0.ɵɵtext(1, \" ngx-csv-parser works! \");\n      i0.ɵɵelementEnd();\n    }\n  },\n  encapsulation: 2\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxCsvParserComponent, [{\n    type: Component,\n    args: [{\n      selector: 'lib-ngx-csv-parser',\n      template: `\n    <p>\n      ngx-csv-parser works!\n    </p>\n  `\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n\nclass NgxCsvParserModule {}\n\nNgxCsvParserModule.ɵfac = function NgxCsvParserModule_Factory(t) {\n  return new (t || NgxCsvParserModule)();\n};\n\nNgxCsvParserModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxCsvParserModule\n});\nNgxCsvParserModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [NgxCsvParser]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxCsvParserModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [NgxCsvParserComponent],\n      imports: [],\n      providers: [NgxCsvParser],\n      exports: [NgxCsvParserComponent]\n    }]\n  }], null, null);\n})();\n/*\r\n * Public API Surface of ngx-csv-parser\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { NgxCSVParserError, NgxCsvParser, NgxCsvParserComponent, NgxCsvParserModule };","map":{"version":3,"names":["i0","Injectable","Component","NgModule","Observable","NgxCSVParserError","NgxCsvParser","constructor","defaultCSVParserConfig","header","delimiter","encoding","parse","csvFile","config","ngxCSVParserObserver","observer","csvRecords","isCSVFile","reader","FileReader","readAsText","onload","csvData","result","trim","csvRecordsArray","csvStringToArray","headersRow","getHeaderArray","getDataRecordsArrayFromCSVFile","length","next","complete","onerror","badCSVDataFormatErrorHandler","notCSVFileErrorHandler","error","unknownCSVParserErrorHandler","csvDataString","regexPattern","RegExp","matchedPatternArray","exec","resultCSV","push","cleanValue","replace","headerLength","dataArr","headersArray","startingRowToParseData","i","data","csvRecord","j","undefined","file","name","toLowerCase","endsWith","csvRecordsArr","headers","headerArray","ngcCSVParserError","errorBuilder","type","message","code","ɵfac","ɵprov","args","providedIn","NgxCsvParserComponent","ngOnInit","ɵcmp","selector","template","NgxCsvParserModule","ɵmod","ɵinj","declarations","imports","providers","exports"],"sources":["/Users/kristiyanmerdzhov/Repos/SEP-Gruppe-B/tipphub/src/main/Client/node_modules/ngx-csv-parser/fesm2020/ngx-csv-parser.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, Component, NgModule } from '@angular/core';\nimport { Observable } from 'rxjs';\n\nclass NgxCSVParserError {\r\n}\n\nclass NgxCsvParser {\r\n    constructor() {\r\n        this.defaultCSVParserConfig = {\r\n            header: true,\r\n            delimiter: ',',\r\n            encoding: 'utf8'\r\n        };\r\n    }\r\n    parse(csvFile, config) {\r\n        config = {\r\n            ...this.defaultCSVParserConfig,\r\n            ...config\r\n        };\r\n        const ngxCSVParserObserver = new Observable((observer) => {\r\n            try {\r\n                let csvRecords = null;\r\n                if (this.isCSVFile(csvFile)) {\r\n                    const reader = new FileReader();\r\n                    reader.readAsText(csvFile, config.encoding);\r\n                    reader.onload = () => {\r\n                        const csvData = reader.result.trim();\r\n                        if (csvData) {\r\n                            const csvRecordsArray = this.csvStringToArray(csvData, config.delimiter);\r\n                            const headersRow = this.getHeaderArray(csvRecordsArray);\r\n                            csvRecords =\r\n                                this.getDataRecordsArrayFromCSVFile(csvRecordsArray, headersRow.length, config);\r\n                            observer.next(csvRecords);\r\n                        }\r\n                        else {\r\n                            observer.next([]);\r\n                        }\r\n                        observer.complete();\r\n                    };\r\n                    reader.onerror = () => {\r\n                        this.badCSVDataFormatErrorHandler(observer);\r\n                    };\r\n                }\r\n                else {\r\n                    this.notCSVFileErrorHandler(observer);\r\n                }\r\n            }\r\n            catch (error) {\r\n                this.unknownCSVParserErrorHandler(observer);\r\n            }\r\n        });\r\n        return ngxCSVParserObserver;\r\n    }\r\n    csvStringToArray(csvDataString, delimiter) {\r\n        const regexPattern = new RegExp(`(\\\\${delimiter}|\\\\r?\\\\n|\\\\r|^)(?:\\\"((?:\\\\\\\\.|\\\"\\\"|[^\\\\\\\\\\\"])*)\\\"|([^\\\\${delimiter}\\\"\\\\r\\\\n]*))`, 'gi');\r\n        let matchedPatternArray = regexPattern.exec(csvDataString);\r\n        const resultCSV = [[]];\r\n        while (matchedPatternArray) {\r\n            if (matchedPatternArray[1].length &&\r\n                matchedPatternArray[1] !== delimiter) {\r\n                resultCSV.push([]);\r\n            }\r\n            const cleanValue = matchedPatternArray[2]\r\n                ? matchedPatternArray[2].replace(new RegExp('[\\\\\\\\\"](.)', 'g'), '$1')\r\n                : matchedPatternArray[3];\r\n            resultCSV[resultCSV.length - 1].push(cleanValue);\r\n            matchedPatternArray = regexPattern.exec(csvDataString);\r\n        }\r\n        return resultCSV;\r\n    }\r\n    getDataRecordsArrayFromCSVFile(csvRecordsArray, headerLength, config) {\r\n        const dataArr = [];\r\n        const headersArray = csvRecordsArray[0];\r\n        const startingRowToParseData = config.header ? 1 : 0;\r\n        for (let i = startingRowToParseData; i < csvRecordsArray.length; i++) {\r\n            const data = csvRecordsArray[i];\r\n            if (data.length === headerLength && config.header) {\r\n                const csvRecord = {};\r\n                for (let j = 0; j < data.length; j++) {\r\n                    if (data[j] === undefined || data[j] === null) {\r\n                        csvRecord[headersArray[j]] = '';\r\n                    }\r\n                    else {\r\n                        csvRecord[headersArray[j]] = data[j].trim();\r\n                    }\r\n                }\r\n                dataArr.push(csvRecord);\r\n            }\r\n            else {\r\n                dataArr.push(data);\r\n            }\r\n        }\r\n        return dataArr;\r\n    }\r\n    isCSVFile(file) {\r\n        return file.name.toLowerCase().endsWith('.csv');\r\n    }\r\n    getHeaderArray(csvRecordsArr) {\r\n        const headers = csvRecordsArr[0];\r\n        const headerArray = [];\r\n        for (const header of headers) {\r\n            headerArray.push(header);\r\n        }\r\n        return headerArray;\r\n    }\r\n    notCSVFileErrorHandler(observer) {\r\n        const ngcCSVParserError = this.errorBuilder('NOT_A_CSV_FILE', 'Selected file is not a csv File Type.', 2);\r\n        observer.error(ngcCSVParserError);\r\n    }\r\n    unknownCSVParserErrorHandler(observer) {\r\n        const ngcCSVParserError = this.errorBuilder('UNKNOWN_ERROR', 'Unknown error. Please refer to official documentation for library usage.', 404);\r\n        observer.error(ngcCSVParserError);\r\n    }\r\n    badCSVDataFormatErrorHandler(observer) {\r\n        const ngcCSVParserError = this.errorBuilder('BAD_CSV_DATA_FORMAT', 'Unable to parse CSV File.', 1);\r\n        observer.error(ngcCSVParserError);\r\n    }\r\n    errorBuilder(type, message, code) {\r\n        const ngcCSVParserError = new NgxCSVParserError();\r\n        ngcCSVParserError.type = type;\r\n        ngcCSVParserError.message = message;\r\n        ngcCSVParserError.code = code;\r\n        return ngcCSVParserError;\r\n    }\r\n}\r\nNgxCsvParser.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.3\", ngImport: i0, type: NgxCsvParser, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nNgxCsvParser.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.3\", ngImport: i0, type: NgxCsvParser, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.3\", ngImport: i0, type: NgxCsvParser, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }] });\n\nclass NgxCsvParserComponent {\r\n    constructor() { }\r\n    ngOnInit() {\r\n    }\r\n}\r\nNgxCsvParserComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.3\", ngImport: i0, type: NgxCsvParserComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\r\nNgxCsvParserComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"14.1.3\", type: NgxCsvParserComponent, selector: \"lib-ngx-csv-parser\", ngImport: i0, template: `\n    <p>\n      ngx-csv-parser works!\n    </p>\n  `, isInline: true });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.3\", ngImport: i0, type: NgxCsvParserComponent, decorators: [{\r\n            type: Component,\r\n            args: [{ selector: 'lib-ngx-csv-parser', template: `\n    <p>\n      ngx-csv-parser works!\n    </p>\n  ` }]\r\n        }], ctorParameters: function () { return []; } });\n\nclass NgxCsvParserModule {\r\n}\r\nNgxCsvParserModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.3\", ngImport: i0, type: NgxCsvParserModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nNgxCsvParserModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.1.3\", ngImport: i0, type: NgxCsvParserModule, declarations: [NgxCsvParserComponent], exports: [NgxCsvParserComponent] });\r\nNgxCsvParserModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.1.3\", ngImport: i0, type: NgxCsvParserModule, providers: [NgxCsvParser] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.3\", ngImport: i0, type: NgxCsvParserModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    declarations: [NgxCsvParserComponent],\r\n                    imports: [],\r\n                    providers: [NgxCsvParser],\r\n                    exports: [NgxCsvParserComponent]\r\n                }]\r\n        }] });\n\n/*\r\n * Public API Surface of ngx-csv-parser\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { NgxCSVParserError, NgxCsvParser, NgxCsvParserComponent, NgxCsvParserModule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}